---
title: 정렬 알고리즘
date: January 25, 2023
description: 알고리즘 스터디 3주차 정렬 알고리즘
category: algorithm, javascript
---

## 버블 정렬(Bubble Sort)

<p align="center">
  <img src="/images/post/03_2023-01-25/bubble.gif" alt="Bubble Sort" />
</p>

인접한 두 원소를 계속해서 비교하며 거품이 수면위로 올라오는 듯한 모습으로 정렬하는 알고리즘

- O(n²)

```jsx
const bubbleSort = (input) => {
  const leng = input.length;
  for (let i = 0; i < leng; i++) {
    for (let j = 0; j < leng; j++) {
      if (input[j] > input[j + 1]) {
        [input[j], input[j + 1]] = [input[j + 1], input[j]];
      }
    }
  }
  return input;
};
```

## 선택 정렬(Selection Sort)

<p align="center">
  <img src="/images/post/03_2023-01-25/selection.gif" alt="Selection Sort" />
</p>

매번 최소값 or 최대값을 찾아 선택하고 알맞은 위치의 요소와 스왑하는 정렬 알고리즘

- O(n²)

```jsx
const selectionSort = (input) => {
  const leng = input.length;
  for (let i = 0; i < leng; i++) {
    let minIndex = i;
    for (let j = i + 1; j < leng; j++) {
      if (input[minIndex] > input[j]) minIndex = j;
    }
    if (minIndex !== i) {
      [input[i], input[minIndex]] = [input[minIndex], input[i]];
    }
  }
  return input;
};
```

## 삽입 정렬(Insertion Sort)

<p align="center">
  <img src="/images/post/03_2023-01-25/insertion.gif" alt="Insertion Sort" />
</p>

데이터를 정렬/비정렬 영역으로 나누고 비정렬 영역의 데이터를 순회하면서 정렬 영역의 적절한 위치에 삽입하는 정렬 알고리즘

- 최악의 경우 O(n²)
- 최선의 경우 O(n)

```jsx
const insertSort = (input) => {
  const leng = input.length;
  for (let i = 1; i < leng; i++) {
    const currentValue = input[i];
    for (let j = i - 1; j >= 0 && input[j] > currentValue; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = currentValue;
  }
  return input;
};
```

## 합병 정렬(Merge Sort)

<p align="center">
  <img src="/images/post/03_2023-01-25/merge.gif" alt="Merge Sort" />
</p>

둘 이상의 부분집합으로 나누고 각각을 정렬한 다음, 정렬된 채로 합치는 분할 정복 정렬 알고리즘

- O(n log n)

```jsx
const merge = (left, right) => {
  const result = [];
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  return [...result, ...left, ...right];
};

const mergeSort = (input) => {
  const leng = input.length;
  if (leng < 2) {
    return input;
  }
  const mid = Math.ceil(leng / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);
  return merge(mergeSort(left), mergeSort(right));
};
```

## 퀵 정렬(Quick Sort)

<p align="center">
  <img src="/images/post/03_2023-01-25/quick.gif" alt="Quick Sort" />
</p>

집합내 임의의 피벗(Pivot)을 정하고, 해당 비벗을 기준으로 두개의 부분 집합으로 나눠 한쪽에는 작은 값, 반대쪽에는 큰값들만 넣는 방식을 재귀적으로 수행하는 정렬 알고리즘

- 평균, 최선의 경우 O(n log n)
- 최악의 경우 O(n²)

```jsx
const quickSort = (input) => {
  const leng = input.length;
  if (leng < 2) {
    return array;
  }
  const pivot = [array[0]];
  const left = [];
  const right = [];

  for (let i = 1; i < leng; i++) {
    if (array[i] < pivot) {
      left.push(array[i]);
    } else if (array[i] > pivot) {
      right.push(array[i]);
    } else {
      pivot.push(array[i]);
    }
  }
  return [...quickSort(left), ...pivot, ...quickSort(right)];
};
```
